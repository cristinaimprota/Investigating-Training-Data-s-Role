import string

class DocCleaner:

    SUPPORTED_PATTERNS = ['args', 'xxx\n===', 'xxx\n---', 'xxx\n>>>', '*xxx*', '->', 'todo', 'CAPS /x/x/x', 'x CAPS /x/x/x',
                          'example', ':xxx', 'xxx:', '@xxx', '# xxx', 'e.g.', '.. xxx::', 'punctuation_numbers']
    
    def __init__(self, doc):
        self.doc = doc
        self.processed_doc = doc
        self.pattern = []
        self.is_to_discard = False
        self.discard_reason = ''

    def clean_doc(self):
        self.processed_doc = self.doc.replace('"""', '').strip().replace('# noqa: E501', '')
        if self.is_empty_doc(self): # remove empty doc
            return
        # if self.is_test_function(self): # remove test function
        #     return
        if self.is_deprecated_funciton(self): # remove deprecated functions
            return
        if self.is_convenience_fluent_method(self): # convenience fluent method
            return
        # if self.is_autogenerated_function(self): # remove autogenerated functions
        #     return
        # search for patterns to clean the doc
    
        processed_doc_lines = [line.strip() for line in self.processed_doc.split('\n') if line.strip() != '']
        processed_doc_lines = [line for line in processed_doc_lines if not ((line.split() == 1) and line.startswith('|') and line.endswith('|'))] # |xxx|
        self.processed_doc = '\n'.join(processed_doc_lines)
        while True:
            pattern = self.check_patterns(processed_doc_lines)
            self.pattern.append(pattern)
            if pattern == 'none':        
                break
            if pattern in self.SUPPORTED_PATTERNS:
                processed_doc_lines = self.clean_pattern(self, processed_doc_lines, pattern)
                if len(processed_doc_lines) == 0:
                    self.is_to_discard = True
                    self.discard_reason = 'empty_doc'
                    return
                self.processed_doc = '\n'.join(processed_doc_lines)
            else:
                break

        self.isascii(self)
        self.is_too_short(self)

    @staticmethod
    def clean_pattern(self, processed_doc_lines, pattern):
        if pattern == '->':
            return self.clean_pattern_arrow(processed_doc_lines)
        if pattern == 'args':
            return self.clean_pattern_args(processed_doc_lines)
        if pattern == 'xxx\n>>>':
            return self.clean_pattern_angular(processed_doc_lines)
        if pattern == 'xxx\n===':
            return self.clean_pattern_equals(processed_doc_lines)
        if pattern == 'xxx\n---':
            return self.clean_pattern_trattino(processed_doc_lines)
        if pattern == '*xxx*':
            return self.clean_pattern_stars(processed_doc_lines)
        if pattern == 'example':
            return self.clean_pattern_example(processed_doc_lines)
        if pattern == '@xxx':
            return self.clean_pattern_chiocciola(processed_doc_lines)
        if pattern == '# xxx':
            return self.clean_pattern_hashtag(processed_doc_lines)
        if pattern == 'xxx:':
            return self.clean_pattern_end_colon(processed_doc_lines)
        if pattern == ':xxx':
            return self.clean_pattern_start_colon(processed_doc_lines)
        if pattern == 'e.g.':
            return self.clean_pattern_eg(processed_doc_lines)
        if pattern == '.. xxx::':
            return self.clean_pattern_double_colon(processed_doc_lines)
        if pattern == 'punctuation_numbers':
            return self.clean_pattern_punctuation(processed_doc_lines)
        if pattern == 'todo':
            return self.clean_pattern_todo(processed_doc_lines)
        if pattern == 'CAPS /x/x/x':
            return self.clean_pattern_caps(processed_doc_lines)
        if pattern == 'x CAPS /x/x/x':
            return self.clean_pattern_caps2(processed_doc_lines)
        return processed_doc_lines
  
    @staticmethod
    def clean_pattern_arrow(_doc_lines):
        return _doc_lines[1:]

    @staticmethod
    def clean_pattern_args(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.lower().startswith('args'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_angular(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('>>>'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_equals(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('==='):
                # remove previous line
                cleaned_doc_lines = cleaned_doc_lines[:-1]
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_trattino(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('---'):
                # remove previous line
                cleaned_doc_lines = cleaned_doc_lines[:-1]
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_stars(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('*') and line.endswith('*'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_example(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('Example'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_chiocciola(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('@'):
                if len(cleaned_doc_lines) > 0 and len(cleaned_doc_lines[0].split()) == 1:
                    # remove previous line
                    cleaned_doc_lines = cleaned_doc_lines[:-1]
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_hashtag(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('#'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_end_colon(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line == '':
                cleaned_doc_lines.append(line)
                continue
            if line.split()[0].endswith(':') or (len(line.split()) > 1 and line.split()[1].endswith(':')):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_start_colon(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith(':'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_eg(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.lower().startswith('e.g.'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_double_colon(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.startswith('..') and line.split()[1].endswith('::'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_punctuation(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if len([1 for c in line.replace(' ', '') if (c in string.punctuation or c.isdigit())])\
                    == len(line.replace(' ', '')):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def clean_pattern_todo(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if line.lower().startswith('todo'):
                break
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines   
    
    @staticmethod
    def clean_pattern_caps(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if (line.split()[0] == line.split()[0].upper() and '/' in line):
                continue
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines
    
    @staticmethod
    def clean_pattern_caps2(_doc_lines):
        cleaned_doc_lines = []
        for line in _doc_lines:
            if (len(line.split()) > 1 and line.split()[1] == line.split()[1].upper() and '/' in line):
                continue
            cleaned_doc_lines.append(line)
        return cleaned_doc_lines

    @staticmethod
    def is_autogenerated_function(self):
        if 'autogenerated' in self.processed_doc.lower().split('\n')[0]:
            self.is_to_discard = True
            self.discard_reason = 'is_autogenerated_function'
            return True
        return False
  
    # @staticmethod
    # def is_test_function(self):
    #     if self.processed_doc.lower().startswith('test'):
    #         self.is_to_discard = True
    #         self.discard_reason = 'is_test_function'
    #         return True
    #     return False

    @staticmethod
    def is_deprecated_funciton(self):
        if 'deprecated' in self.processed_doc.lower().split('\n')[0]:
            self.is_to_discard = True
            self.discard_reason = 'is_deprecated_function'
            return True
        return False

    @staticmethod
    def is_empty_doc(self):
        if self.processed_doc == '':
            self.is_to_discard = True
            self.discard_reason = 'empty_doc'
            return True
        return False

    @staticmethod
    def isascii(self):
        if len(self.processed_doc) != len(self.processed_doc.encode()):
            self.is_to_discard = True
            self.discard_reason = 'contains_non_ascii_char'
    
    @staticmethod
    def is_too_short(self):
        if len(self.processed_doc.split()) < 10:
            self.is_to_discard = True
            self.discard_reason = 'too_short'
    
    @staticmethod
    def is_convenience_fluent_method(self):
        if self.processed_doc.lower().startswith('convenience fluent method for'):
            self.is_to_discard = True
            self.discard_reason = 'convenience_method'

    @staticmethod
    def check_patterns(processed_doc_lines):
        if '->' in processed_doc_lines[0]:
            return '->'
        if len([1 for line in processed_doc_lines if line.lower().startswith('args')]) > 0:
            return 'args'
        elif len([1 for line in processed_doc_lines if line.startswith(':')]) > 0:
            return ':xxx'
        elif len([1 for line in processed_doc_lines if line.startswith('---')]) > 0:
            return 'xxx\n---'
        elif len([1 for line in processed_doc_lines if line.startswith('>>>')]) > 0:
            return 'xxx\n>>>'
        elif len([1 for line in processed_doc_lines if line.startswith('===')]) > 0:
            return 'xxx\n==='
        elif len([1 for line in processed_doc_lines if line.startswith('@')]) > 0:
            return '@xxx'
        elif len([1 for line in processed_doc_lines if (line.split()[0].endswith(':')
                                                    or (len(line.split()) > 1 and line.split()[1].endswith(':')))]) > 0:
            return 'xxx:'
        elif len([1 for line in processed_doc_lines if line.startswith('#')]) > 0:
            return '# xxx'
        elif len([1 for line in processed_doc_lines if (line.startswith('*') and line.endswith('*'))]) > 0:
            return '*xxx*'
        elif len([1 for line in processed_doc_lines if line.startswith('Example')]) > 0:
            return 'example'
        elif len([1 for line in processed_doc_lines if line.startswith('<p>')]) > 0:
            return '<p>'
        elif len([1 for j in range(len(processed_doc_lines)) if (processed_doc_lines[j].lower().startswith('e.g.')
                                                                and processed_doc_lines[j-1].endswith('.'))]) > 0:
            return 'e.g.'
        elif len([1 for line in processed_doc_lines if 
                    len([1 for c in line.replace(' ', '') if (c in string.punctuation or c.isdigit())])\
                    == len(line.replace(' ', ''))]) > 0:
            return 'punctuation_numbers'
        elif len([1 for line in processed_doc_lines if (line.startswith('..')
                                                    and len(line.split()) > 1
                                                    and line.split()[1].endswith('::'))]) > 0:
            return '.. xxx::'
        elif len([1 for line in processed_doc_lines if line.lower().startswith('todo')]) > 0:
            return 'todo'
        # elif len([1 for line in processed_doc_lines if (line == line.upper() 
        #                                             # is not only numbers and punctuation
        #                                             and len([1 for c in line.replace(' ', '') if (c in string.punctuation or c.isdigit())])\
        #                                                 != len(line.replace(' ', '')))]) > 0:
        #     return 'CAPS'

        # check first token only
        elif len([1 for line in processed_doc_lines if (line.split()[0] == line.split()[0].upper() and '/' in line)]) > 0:
            return 'CAPS /x/x/x'
        elif len([1 for line in processed_doc_lines if (len(line.split()) > 1 and '/' in line 
                                                        and line.split()[1] == line.split()[1].upper())]) > 0:
            return 'x CAPS /x/x/x'
        elif len([1 for line in processed_doc_lines if line.startswith('DPP')]) > 0:
            return 'DPP'
        return 'none'
